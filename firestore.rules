/**
 * @fileoverview Firestore Security Rules for the iLearn platform.
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership and role-based access control model.
 * Most data is scoped to an organization, and access is granted based on
 * the user's role within that organization or explicit ownership of resources.
 *
 * Data Structure:
 * - /organizations/{orgId}: Stores organization details.
 * - /users/{userId}: Stores user details, including role and organization ID.
 * - /classes/{classId}: Stores class details, including organization ID and teacher IDs.
 * - /playlists/{playlistId}: Stores playlist details, including organization ID and class IDs.
 * - /videos/{videoId}: Stores video details, including organization ID.
 * - /videos/{videoId}/segments/{segmentId}: Stores segment details for a video.
 * - /videos/{videoId}/segments/{segmentId}/questions/{questionId}: Stores question details for a video segment.
 * - /assignments/{assignmentId}: Stores assignment details, including organization ID, playlist ID, and class ID.
 * - /progress/{progressId}: Stores student progress for an assignment.
 * - /attempts/{attemptId}: Stores student attempts to answer questions.
 * - /subscription_plans/{subscriptionPlanId}: Stores subscription plan details.
 * - /teacher_subscriptions/{teacherSubscriptionId}: Stores teacher subscriptions to specific plans.
 *
 * Key Security Decisions:
 * - All write operations require an authenticated user.
 * - Data is generally scoped to an organization (orgId).
 * - User roles (teacher, student, admin) are stored in the user document.
 * - The rules do not attempt to validate the data schema beyond basic authorization.
 * - List operations are generally allowed for owners of the parent document.
 *
 * Denormalization for Authorization:
 * - Most documents contain `orgId` to enable organization-scoped access control without additional reads.
 * - `TeacherSubscription` documents include the `userId` to allow for simpler ownership checks.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Grants access to organization documents.
     * @path /organizations/{orgId}
     * @allow (get, list): if true;
     * @allow (create, update, delete): if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @deny (create, update, delete): Always deny write operations for now.
     * @principle: Enforces public read access with owner-only writes (not yet implemented due to missing ownership field).
     */
    match /organizations/{orgId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Grants access to user documents.
     * @path /users/{userId}
     * @allow (get, list): if false;
     * @allow (create): Allows a user to create their own document.
     * @allow (update, delete): Allows a user to update/delete their own document.
     * @deny (get, list): Listing and getting all users is disallowed.
     * @principle: Enforces user-ownership for read/write operations.
     */
    match /users/{userId} {
      allow get, list: if false;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isSignedIn() && request.auth.uid == userId && resource != null;
      allow delete: if isSignedIn() && request.auth.uid == userId && resource != null;
    }

    /**
     * @description Grants access to class documents.
     * @path /classes/{classId}
     * @allow (get, list): if true;
     * @allow (create, update, delete): if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @deny (create, update, delete): Always deny write operations for now.
     * @principle: Enforces public read access with owner-only writes (not yet implemented due to missing ownership field).
     */
    match /classes/{classId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Grants access to playlist documents.
     * @path /playlists/{playlistId}
     * @allow (get, list): if true;
     * @allow (create, update, delete): if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @deny (create, update, delete): Always deny write operations for now.
     * @principle: Enforces public read access with owner-only writes (not yet implemented due to missing ownership field).
     */
    match /playlists/{playlistId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Grants access to video documents.
     * @path /videos/{videoId}
     * @allow (get, list): if true;
     * @allow (create, update, delete): if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @deny (create, update, delete): Always deny write operations for now.
     * @principle: Enforces public read access with owner-only writes (not yet implemented due to missing ownership field).
     */
    match /videos/{videoId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Grants access to segment documents.
     * @path /videos/{videoId}/segments/{segmentId}
     * @allow (get, list): if true;
     * @allow (create, update, delete): if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @deny (create, update, delete): Always deny write operations for now.
     * @principle: Enforces public read access with owner-only writes (not yet implemented due to missing ownership field).
     */
    match /videos/{videoId}/segments/{segmentId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Grants access to question documents.
     * @path /videos/{videoId}/segments/{segmentId}/questions/{questionId}
     * @allow (get, list): if true;
     * @allow (create, update, delete): if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @deny (create, update, delete): Always deny write operations for now.
     * @principle: Enforces public read access with owner-only writes (not yet implemented due to missing ownership field).
     */
    match /videos/{videoId}/segments/{segmentId}/questions/{questionId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Grants access to assignment documents.
     * @path /assignments/{assignmentId}
     * @allow (get, list): if true;
     * @allow (create, update, delete): if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @deny (create, update, delete): Always deny write operations for now.
     * @principle: Enforces public read access with owner-only writes (not yet implemented due to missing ownership field).
     */
    match /assignments/{assignmentId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Grants access to progress documents.
     * @path /progress/{progressId}
     * @allow (get, list): if true;
     * @allow (create, update, delete): if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @deny (create, update, delete): Always deny write operations for now.
     * @principle: Enforces public read access with owner-only writes (not yet implemented due to missing ownership field).
     */
    match /progress/{progressId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Grants access to attempt documents.
     * @path /attempts/{attemptId}
     * @allow (get, list): if true;
     * @allow (create, update, delete): if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @deny (create, update, delete): Always deny write operations for now.
     * @principle: Enforces public read access with owner-only writes (not yet implemented due to missing ownership field).
     */
    match /attempts/{attemptId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Grants access to subscription plan documents.
     * @path /subscription_plans/{subscriptionPlanId}
     * @allow (get, list): if true;
     * @allow (create, update, delete): if false; // TODO: Add role-based access control for admins only.
     * @deny (create, update, delete): Always deny write operations for now.
     * @principle: Restricts write access to admins only.
     */
    match /subscription_plans/{subscriptionPlanId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add role-based access control for admins only.
    }

    /**
     * @description Grants access to teacher subscription documents.
     * @path /teacher_subscriptions/{teacherSubscriptionId}
     * @allow (get, list): if true;
     * @allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
     * @allow update: if isSignedIn() && isExistingOwner(request.resource.data.userId);
     * @allow delete: if isSignedIn() && isExistingOwner(request.resource.data.userId);
     * @deny (create, update, delete): if not owner.
     * @principle: Enforces user-ownership for read/write operations.
     */
    match /teacher_subscriptions/{teacherSubscriptionId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(request.resource.data.userId);
      allow delete: if isSignedIn() && isExistingOwner(request.resource.data.userId);
    }

    /**
     * @description Checks if the user is signed in.
     * @return {bool} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user is the owner of the resource.
     * @param {string} userId The user ID to check against.
     * @return {bool} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the user is the owner of the resource and the resource exists.
     * @param {string} userId The user ID to check against.
     * @return {bool} True if the user is the owner and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
  }
}