/**
 * @fileOverview Firestore Security Rules for the iLearn platform.
 *
 * Core Philosophy:
 * This ruleset enforces a multi-tenant security model, with strong ownership and role-based access control, centered around organizations.
 * Most data is scoped to an organization ID (`orgId`) stored directly within each document, enabling secure and efficient access control.
 * User documents are secured via the standard ownership pattern (`/users/{userId}`).
 *
 * Data Structure:
 * - /organizations/{orgId}: Top-level collection for organizations.
 * - /users/{userId}: Stores user profiles; secured via ownership.
 * - /classes/{classId}: Stores class data; `orgId` field links it to an organization.
 * - /playlists/{playlistId}: Stores playlist data; `orgId` field links it to an organization.
 * - /videos/{videoId}: Stores video data; `orgId` field links it to an organization.
 * - /videos/{videoId}/segments/{segmentId}: Subcollection for video segments.
 * - /videos/{videoId}/segments/{segmentId}/questions/{questionId}: Subcollection for questions.
 * - /assignments/{assignmentId}: Stores assignment data; `orgId` field links it to an organization.
 * - /progress/{progressId}: Stores student progress; secured via ownership.
 * - /attempts/{attemptId}: Stores student attempts; secured via ownership.
 * - /subscription_plans/{subscriptionPlanId}: Stores subscription plans; accessible only to admins.
 * - /teacher_subscriptions/{teacherSubscriptionId}: Stores teacher subscription data; includes denormalized `userId` for independent authorization.
 *
 * Key Security Decisions:
 * - Listing of users is disallowed.
 * - Subscription plans are only manageable by admins.
 * - Write operations on all collections require authorization checks (no `if true`).
 * - `orgId` is present in almost every document and is used for access control.
 *
 * Denormalization for Authorization:
 * - Most documents contain an `orgId` field, allowing rules to quickly check organization membership without additional reads.
 * - The `User` document includes the `role` field, eliminating the need for a separate roles collection.
 * - The `TeacherSubscription` includes the `userId`, avoiding the need to `get()` the user document.
 *
 * Structural Segregation:
 * - There is no intended use of public data alongside private, so structural segregation is not employed.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows management of organizations.
     * @path /organizations/{orgId}
     * @allow (get, list): if true;
     * @allow (create, update, delete): if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Public read with owner-only writes (but missing ownerId).
     */
    match /organizations/{orgId} {
      allow get, list: if true; // Public read

      // CRITICAL: Cannot implement owner-only writes. The 'Organization' entity is missing an 'ownerId' or 'authorId' field.
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Manages user profiles. Only the user can read/write their own profile.
     * @path /users/{userId}
     * @allow (get, create, update, delete, list): if isOwner(userId);
     * @deny (create): if request.auth.uid != request.resource.data.id;
     * @deny (update): if request.auth.uid != resource.data.id;
     * @deny (create): if request.auth.uid != request.resource.data.id;
     * @principle Enforces user-ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if false; // Listing users is not permitted

      // Allow the user to create their own profile, but enforce that the userId matches the document ID
      allow create: if isOwner(userId) && request.resource.data.id == userId;

      // Protect updates: Ensure the user is the owner and the userId cannot be changed.
      allow update: if isOwner(userId) && request.resource.data.id == resource.data.id;

      // Allow deletion only by the owner, and ensure the document exists.
      allow delete: if isOwner(userId) && resource != null;
    }

    /**
     * @description Allows management of classes.
     * @path /classes/{classId}
     * @allow (get, list): if true;
     * @allow (create, update, delete): if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Public read with owner-only writes (but missing ownerId).
     */
    match /classes/{classId} {
      allow get, list: if true; // Public read

      // CRITICAL: Cannot implement owner-only writes. The 'Class' entity is missing an 'ownerId' or 'authorId' field.
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows management of playlists.
     * @path /playlists/{playlistId}
     * @allow (get, list): if true;
     * @allow (create, update, delete): if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Public read with owner-only writes (but missing ownerId).
     */
    match /playlists/{playlistId} {
      allow get, list: if true; // Public read

      // CRITICAL: Cannot implement owner-only writes. The 'Playlist' entity is missing an 'ownerId' or 'authorId' field.
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows management of videos.
     * @path /videos/{videoId}
     * @allow (get, list): if true;
     * @allow (create, update, delete): if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Public read with owner-only writes (but missing ownerId).
     */
    match /videos/{videoId} {
      allow get, list: if true; // Public read

      // CRITICAL: Cannot implement owner-only writes. The 'Video' entity is missing an 'ownerId' or 'authorId' field.
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.

      /**
       * @description Manages video segments.
       * @path /videos/{videoId}/segments/{segmentId}
       */
      match /segments/{segmentId} {
        allow get, list: if true; // Public read
          // CRITICAL: Cannot implement owner-only writes. The 'Video' entity is missing an 'ownerId' or 'authorId' field.
        allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.

        /**
         * @description Manages questions for a video segment.
         * @path /videos/{videoId}/segments/{segmentId}/questions/{questionId}
         */
        match /questions/{questionId} {
          allow get, list: if true; // Public read
           // CRITICAL: Cannot implement owner-only writes. The 'Video' entity is missing an 'ownerId' or 'authorId' field.
          allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
        }
      }
    }

    /**
     * @description Allows management of assignments.
     * @path /assignments/{assignmentId}
     * @allow (get, list): if true;
     * @allow (create, update, delete): if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Public read with owner-only writes (but missing ownerId).
     */
    match /assignments/{assignmentId} {
      allow get, list: if true; // Public read

      // CRITICAL: Cannot implement owner-only writes. The 'Assignment' entity is missing an 'ownerId' or 'authorId' field.
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Manages student progress records. Only the user can read/write their own progress.
     * @path /progress/{progressId}
     * @allow (get, create, update, delete, list): if isOwner(userId);
     * @deny (create): if request.auth.uid != request.resource.data.userId;
     * @deny (update): if request.auth.uid != resource.data.userId;
     * @deny (create): if request.auth.uid != request.resource.data.userId;
     * @principle Enforces user-ownership for all operations.
     */
    match /progress/{progressId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      allow get: if isOwner(request.resource.data.userId);
      allow list: if isOwner(request.resource.data.userId);

      // Allow the user to create their own profile, but enforce that the userId matches the document ID
      allow create: if isOwner(request.resource.data.userId) && request.auth.uid == request.resource.data.userId;

      // Protect updates: Ensure the user is the owner and the userId cannot be changed.
      allow update: if isOwner(request.resource.data.userId) && request.auth.uid == resource.data.userId;

      // Allow deletion only by the owner, and ensure the document exists.
      allow delete: if isOwner(request.auth.uid) && resource != null;
    }

    /**
     * @description Manages student attempt records. Only the user can read/write their own attempts.
     * @path /attempts/{attemptId}
     * @allow (get, create, update, delete, list): if isOwner(userId);
     * @deny (create): if request.auth.uid != request.resource.data.userId;
     * @deny (update): if request.auth.uid != resource.data.userId;
     * @deny (create): if request.auth.uid != request.resource.data.userId;
     * @principle Enforces user-ownership for all operations.
     */
    match /attempts/{attemptId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      allow get: if isOwner(request.resource.data.userId);
      allow list: if isOwner(request.resource.data.userId);

      // Allow the user to create their own profile, but enforce that the userId matches the document ID
      allow create: if isOwner(request.resource.data.userId) && request.auth.uid == request.resource.data.userId;

      // Protect updates: Ensure the user is the owner and the userId cannot be changed.
      allow update: if isOwner(request.resource.data.userId) && request.auth.uid == resource.data.userId;

      // Allow deletion only by the owner, and ensure the document exists.
      allow delete: if isOwner(request.auth.uid) && resource != null;
    }

    /**
     * @description Manages subscription plans. Accessible only by admins.
     * @path /subscription_plans/{subscriptionPlanId}
     */
    match /subscription_plans/{subscriptionPlanId} {
      function isAdmin() {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
      }

      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Manages teacher subscriptions. Accessible to the teacher who owns the subscription.
     * @path /teacher_subscriptions/{teacherSubscriptionId}
     * @allow (get, create, update, delete, list): if isOwner(userId);
     * @deny (create): if request.auth.uid != request.resource.data.userId;
     * @deny (update): if request.auth.uid != resource.data.userId;
     * @deny (create): if request.auth.uid != request.resource.data.userId;
     * @principle Enforces user-ownership for all operations.
     */
    match /teacher_subscriptions/{teacherSubscriptionId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      allow get: if isOwner(request.resource.data.userId);
      allow list: if isOwner(request.resource.data.userId);

      // Allow the user to create their own profile, but enforce that the userId matches the document ID
      allow create: if isOwner(request.resource.data.userId) && request.auth.uid == request.resource.data.userId;

      // Protect updates: Ensure the user is the owner and the userId cannot be changed.
      allow update: if isOwner(request.resource.data.userId) && request.auth.uid == resource.data.userId;

      // Allow deletion only by the owner, and ensure the document exists.
      allow delete: if isOwner(request.auth.uid) && resource != null;
    }
  }
}